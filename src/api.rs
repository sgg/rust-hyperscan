use std::cell::RefCell;
use std::ffi::CStr;
use std::fmt;
use std::mem;
use std::ops::Deref;
use std::os::raw::c_char;
use std::ptr;

use libc;

use constants::*;
use errors::Error;
use raw::*;

/// Compile mode
pub trait Type {
    fn mode() -> u32;

    fn name() -> &'static str;
}

/// Block scan (non-streaming) database.
#[derive(Debug)]
pub enum Block {}

/// Streaming database.
#[derive(Debug)]
pub enum Streaming {}

/// Vectored scanning database.
#[derive(Debug)]
pub enum Vectored {}

impl Type for Block {
    #[inline]
    fn mode() -> u32 {
        HS_MODE_BLOCK
    }

    #[inline]
    fn name() -> &'static str {
        "Block"
    }
}

impl Type for Streaming {
    #[inline]
    fn mode() -> u32 {
        HS_MODE_STREAM
    }

    #[inline]
    fn name() -> &'static str {
        "Streaming"
    }
}
impl Type for Vectored {
    #[inline]
    fn mode() -> u32 {
        HS_MODE_VECTORED
    }

    #[inline]
    fn name() -> &'static str {
        "Vectored"
    }
}

/// Raw `Database` pointer
pub type RawDatabasePtr = *mut hs_database_t;

/// A Hyperscan pattern database.
pub trait Database: Deref<Target = RawDatabasePtr> {
    /// Provides the id of compiled mode of the given database.
    fn database_mode(&self) -> u32;

    /// Provides the name of compiled mode of the given database.
    fn database_name(&self) -> &'static str;

    /// Provides the size of the given database in bytes.
    fn database_size(&self) -> Result<usize, Error>;

    /// Utility function providing information about a database.
    fn database_info(&self) -> Result<String, Error>;
}

/// A pattern database can be serialized to a stream of bytes.
pub trait SerializableDatabase<T: Database, S: SerializedDatabase>: Database {
    /// Serialize a pattern database to a stream of bytes.
    fn serialize(&self) -> Result<S, Error>;

    /// Reconstruct a pattern database from a stream of bytes
    /// previously generated by RawDatabase::serialize().
    fn deserialize(bytes: &[u8]) -> Result<T, Error>;

    /// Reconstruct a pattern database from a stream of bytes
    /// previously generated by RawDatabase::serialize() at a given memory location.
    fn deserialize_at(&self, bytes: &[u8]) -> Result<&T, Error>;
}

/// A pattern database was serialized to a stream of bytes.
pub trait SerializedDatabase {
    fn len(&self) -> usize;

    fn as_slice(&self) -> &[u8];

    fn deserialize<T: SerializableDatabase<D, S>, D: Database, S: SerializedDatabase>(&self) -> Result<D, Error> {
        T::deserialize(self.as_slice())
    }

    fn database_size(&self) -> Result<usize, Error> {
        let mut size: usize = 0;

        unsafe {
            check_hs_error!(hs_serialized_database_size(
                self.as_slice().as_ptr() as *const i8,
                self.len(),
                &mut size
            ));
        }

        Ok(size)
    }

    fn database_info(&self) -> Result<String, Error> {
        let mut p: *mut c_char = ptr::null_mut();

        unsafe {
            check_hs_error!(hs_serialized_database_info(
                self.as_slice().as_ptr() as *const i8,
                self.len(),
                &mut p
            ));

            let result = match CStr::from_ptr(p).to_str() {
                Ok(info) => Ok(info.to_string()),
                Err(_) => Err(Error::Invalid),
            };

            libc::free(p as *mut libc::c_void);

            result
        }
    }
}

/// A type containing information on the target platform
/// which may optionally be provided to the compile calls
pub struct PlatformInfo(Option<RefCell<hs_platform_info_t>>);

/// Raw `PlatformInfo` pointer
pub type RawPlatformInfoPtr = *const hs_platform_info_t;

impl fmt::Debug for PlatformInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PlatformInfo({:p})", self.as_ptr())
    }
}

impl PlatformInfo {
    pub fn is_valid() -> bool {
        unsafe { hs_valid_platform() == HS_SUCCESS }
    }

    pub fn null() -> PlatformInfo {
        PlatformInfo(None)
    }

    pub fn host() -> PlatformInfo {
        let mut platform = unsafe { mem::zeroed() };

        unsafe {
            assert_hs_error!(hs_populate_platform(&mut platform));
        }

        PlatformInfo(Some(RefCell::new(platform)))
    }

    pub fn new(tune: u32, cpu_features: u64) -> PlatformInfo {
        PlatformInfo(Some(RefCell::new(hs_platform_info_t {
            tune: tune,
            cpu_features: cpu_features,
            reserved1: 0,
            reserved2: 0,
        })))
    }

    pub fn as_ptr(&self) -> RawPlatformInfoPtr {
        match self.0 {
            Some(ref info) => &*info.borrow(),
            None => ptr::null(),
        }
    }
}

/// The regular expression pattern database builder.
pub trait DatabaseBuilder<D: Database> {
    /// This is the function call with which an expression is compiled into
    /// a Hyperscan database which can be passed to the runtime functions
    fn build(&self) -> Result<D, Error> {
        self.build_for_platform(&PlatformInfo::null())
    }

    fn build_for_platform(&self, platform: &PlatformInfo) -> Result<D, Error>;
}

/// A type containing information related to an expression
#[derive(Debug, Copy, Clone)]
pub struct ExpressionInfo {
    /// The minimum length in bytes of a match for the pattern.
    pub min_width: usize,

    /// The maximum length in bytes of a match for the pattern.
    pub max_width: usize,

    /// Whether this expression can produce matches that are not returned in order,
    /// such as those produced by assertions.
    pub unordered_matches: bool,

    /// Whether this expression can produce matches at end of data (EOD).
    pub matches_at_eod: bool,

    /// Whether this expression can *only* produce matches at end of data (EOD).
    pub matches_only_at_eod: bool,
}

/// Providing expression information.
pub trait Expression {
    ///
    /// Utility function providing information about a regular expression.
    ///
    /// The information provided in ExpressionInfo
    /// includes the minimum and maximum width of a pattern match.
    ///
    fn info(&self) -> Result<ExpressionInfo, Error>;
}

/// Raw `Scratch` pointer
pub type RawScratchPtr = *mut hs_scratch_t;

/// A Hyperscan scratch space.
///
pub trait Scratch: Deref<Target = RawScratchPtr> {
    /// Provides the size of the given scratch space.
    fn size(&self) -> Result<usize, Error>;

    /// Reallocate a "scratch" space for use by Hyperscan.
    fn realloc<T: Database>(&mut self, db: &T) -> Result<&Self, Error>;
}

/// `Scratch` allocator
pub trait ScratchAllocator<S: Scratch> {
    /// Allocate a "scratch" space for use by Hyperscan.
    fn alloc(&self) -> Result<S, Error>;

    /// Reallocate a "scratch" space for use by Hyperscan.
    fn realloc(&self, s: &mut S) -> Result<&Self, Error>;
}

/// A byte stream can be matched
///
pub trait Scannable {
    fn as_bytes(&self) -> &[u8];
}

impl<'a> Scannable for &'a [u8] {
    #[inline]
    fn as_bytes(&self) -> &[u8] {
        &self
    }
}
impl<'a> Scannable for &'a str {
    #[inline]
    fn as_bytes(&self) -> &[u8] {
        str::as_bytes(self)
    }
}
impl<'a> Scannable for &'a String {
    #[inline]
    fn as_bytes(&self) -> &[u8] {
        self.as_str().as_bytes()
    }
}
impl<'a> Scannable for &'a Vec<u8> {
    #[inline]
    fn as_bytes(&self) -> &[u8] {
        &self
    }
}

/// Flags modifying the behaviour of scan function
pub type ScanFlags = u32;

/// Definition of the match event callback function type.
///
/// This callback function will be invoked whenever a match is located in the
/// target data during the execution of a scan. The details of the match are
/// passed in as parameters to the callback function, and the callback function
/// should return a value indicating whether or not matching should continue on
/// the target data. If no callbacks are desired from a scan call, NULL may be
/// provided in order to suppress match production.
///
/// This callback function should not attempt to call Hyperscan API functions on
/// the same stream nor should it attempt to reuse the scratch space allocated
/// for the API calls that caused it to be triggered. Making another call to the
/// Hyperscan library with completely independent parameters should work (for
/// example, scanning a different database in a new stream and with new scratch
/// space), but reusing data structures like stream state and/or scratch space
/// will produce undefined behavior.
///
/// Fn(id: u32, from: u64, to: u64, flags: u32) -> bool
///
pub type MatchEventCallback<D> = fn(id: u32, from: u64, to: u64, flags: u32, data: &D) -> u32;
pub type MatchEventCallbackMut<D> = fn(id: u32, from: u64, to: u64, flags: u32, data: &mut D) -> u32;

/// The block (non-streaming) regular expression scanner.
pub trait BlockScanner<T: Scannable, S: Scratch> {
    /// This is the function call in which the actual pattern matching
    /// takes place for block-mode pattern databases.
    fn scan<D>(
        &self,
        data: T,
        flags: ScanFlags,
        scratch: &S,
        callback: Option<MatchEventCallback<D>>,
        context: Option<&D>,
    ) -> Result<&Self, Error>;

    fn scan_mut<D>(
        // The underlying hyperscan DB is immutable. This should be fine unless this binding
        // introduces mutable state
        &self,
        data: T,
        flags: ScanFlags,
        scratch: &S,
        callback: Option<MatchEventCallbackMut<D>>,
        context: Option<&mut D>,
    ) -> Result<&Self, Error> {
        self.scan(
            data,
            flags,
            scratch,
            // FIXME: This seems TURBO SKETCHY and unecessary and should probably be reevaluated.
            callback.map(|f| unsafe { mem::transmute::<MatchEventCallbackMut<D>, MatchEventCallback<D>>(f) }),
            context.map(|v| &*v),
        )
    }
}

/// The vectored regular expression scanner.
pub trait VectoredScanner<T: Scannable, S: Scratch> {
    /// This is the function call in which the actual pattern matching
    /// takes place for vectoring-mode pattern databases.
    fn scan<D>(
        &self,
        data: &Vec<T>,
        flags: ScanFlags,
        scratch: &S,
        callback: Option<MatchEventCallback<D>>,
        context: Option<&D>,
    ) -> Result<&Self, Error>;
}

/// Raw `Stream` pointer
pub type RawStreamPtr = *mut hs_stream_t;

/// Flags modifying the behaviour of the stream.
pub type StreamFlags = u32;

/// The stream returned by StreamingDatabase::open_stream
pub trait Stream<S: Scratch>: Deref<Target = RawStreamPtr> {
    /// Close a stream.
    fn close<D>(
        &self,
        scratch: &S,
        callback: Option<MatchEventCallback<D>>,
        context: Option<&D>,
    ) -> Result<&Self, Error>;

    /// Reset a stream to an initial state.
    fn reset<D>(
        &self,
        flags: StreamFlags,
        scratch: &S,
        callback: Option<MatchEventCallback<D>>,
        context: Option<&D>,
    ) -> Result<&Self, Error>;
}

/// The streaming regular expression scanner.
pub trait StreamingScanner<T, S>
where
    T: Stream<S>,
    S: Scratch,
{
    /// Open and initialise a stream.
    fn open_stream(&self, flags: StreamFlags) -> Result<T, Error>;
}
